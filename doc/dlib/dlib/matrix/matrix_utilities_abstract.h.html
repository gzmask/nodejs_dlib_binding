<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - matrix_utilities_abstract.h</title></head><body bgcolor='white'><pre>
<font color='#009900'>// Copyright (C) 2006  Davis E. King (davis@dlib.net)
</font><font color='#009900'>// License: Boost Software License   See LICENSE.txt for the full license.
</font><font color='#0000FF'>#undef</font> DLIB_MATRIx_UTILITIES_ABSTRACT_
<font color='#0000FF'>#ifdef</font> DLIB_MATRIx_UTILITIES_ABSTRACT_

<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='matrix_abstract.h.html'>matrix_abstract.h</a>"
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>complex<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../pixel.h.html'>../pixel.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../geometry.h.html'>../geometry.h</a>"
#inclue <font color='#5555FF'>&lt;</font>vector<font color='#5555FF'>&gt;</font>

<font color='#0000FF'>namespace</font> dlib
<b>{</b>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>//                                   Simple matrix utilities 
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='diag'></a>diag</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a column vector R that contains the elements from the diagonal 
              of m in the order R(0)==m(0,0), R(1)==m(1,1), R(2)==m(2,2) and so on.
    !*/</font>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>struct</font> <b><a name='diag_exp'></a>diag_exp</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This struct allows you to determine the type of matrix expression 
                object returned from the diag() function.  An example makes its
                use clear:

                template &lt;typename EXP&gt;
                void do_something( const matrix_exp&lt;EXP&gt;&amp; mat)
                {
                    // d is a matrix expression that aliases mat.
                    typename diag_exp&lt;EXP&gt;::type d = diag(mat);

                    // Print the diagonal of mat.  So we see that by using
                    // diag_exp we can save the object returned by diag() in
                    // a local variable.    
                    cout &lt;&lt; d &lt;&lt; endl;

                    // Note that you can only save the return value of diag() to
                    // a local variable if the argument to diag() has a lifetime
                    // beyond the diag() expression.  The example shown above is
                    // OK but the following would result in undefined behavior:
                    typename diag_exp&lt;EXP&gt;::type bad = diag(mat + mat);
                }
        !*/</font>
        <font color='#0000FF'>typedef</font> type_of_expression_returned_by_diag type;
    <b>}</b>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='diagm'></a>diagm</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(m) == true
              (i.e. m is a row or column matrix)
        ensures
            - returns a square matrix M such that:
                - diag(M) == m
                - non diagonal elements of M are 0
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='trans'></a>trans</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns the transpose of the matrix m
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_type::type <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m1,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m2
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(m1) == true
            - is_vector(m2) == true
            - m1.size() == m2.size()
        ensures
            - returns the dot product between m1 and m2. That is, this function 
              computes and returns the sum, for all i, of m1(i)*m2(i).
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='lowerm'></a>lowerm</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is the lower triangular part of m.  That is:
                    - if (r &gt;= c) then
                        - M(r,c) == m(r,c)
                    - else
                        - M(r,c) == 0
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='lowerm'></a>lowerm</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> matrix_exp::type scalar_value
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is the lower triangular part of m except that the diagonal has
                  been set to scalar_value.  That is:
                    - if (r &gt; c) then
                        - M(r,c) == m(r,c)
                    - else if (r == c) then
                        - M(r,c) == scalar_value 
                    - else
                        - M(r,c) == 0
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='upperm'></a>upperm</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is the upper triangular part of m.  That is:
                    - if (r &lt;= c) then
                        - M(r,c) == m(r,c)
                    - else
                        - M(r,c) == 0
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='upperm'></a>upperm</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> matrix_exp::type scalar_value
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is the upper triangular part of m except that the diagonal has
                  been set to scalar_value.  That is:
                    - if (r &lt; c) then
                        - M(r,c) == m(r,c)
                    - else if (r == c) then
                        - M(r,c) == scalar_value 
                    - else
                        - M(r,c) == 0
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='make_symmetric'></a>make_symmetric</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.nr() == m.nc()
              (i.e. m must be a square matrix)
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is a symmetric matrix, that is, M == trans(M) and
                  it is constructed from the lower triangular part of m.  Specifically,
                  we have:
                    - lowerm(M) == lowerm(m)
                    - upperm(M) == trans(lowerm(m))
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T, 
        <font color='#0000FF'><u>long</u></font> NR, 
        <font color='#0000FF'><u>long</u></font> NC, 
        T val
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='uniform_matrix'></a>uniform_matrix</b> <font face='Lucida Console'>(</font>
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - NR &gt; 0 &amp;&amp; NC &gt; 0
        ensures
            - returns an NR by NC matrix with elements of type T and all set to val.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'><u>long</u></font> NR, 
        <font color='#0000FF'><u>long</u></font> NC
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='uniform_matrix'></a>uniform_matrix</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> val
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - NR &gt; 0 &amp;&amp; NC &gt; 0
        ensures
            - returns an NR by NC matrix with elements of type T and all set to val.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='uniform_matrix'></a>uniform_matrix</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc,
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> val
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - nr &gt; 0 &amp;&amp; nc &gt; 0
        ensures
            - returns an nr by nc matrix with elements of type T and all set to val.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='ones_matrix'></a>ones_matrix</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - nr &gt; 0 &amp;&amp; nc &gt; 0
        ensures
            - returns uniform_matrix&lt;T&gt;(nr, nc, 1)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='zeros_matrix'></a>zeros_matrix</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - nr &gt; 0 &amp;&amp; nc &gt; 0
        ensures
            - returns uniform_matrix&lt;T&gt;(nr, nc, 0)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='identity_matrix'></a>identity_matrix</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'><u>long</u></font> N
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - N &gt; 0
        ensures
            - returns an N by N identity matrix with elements of type T.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T, 
        <font color='#0000FF'><u>long</u></font> N
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='identity_matrix'></a>identity_matrix</b> <font face='Lucida Console'>(</font>
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - N &gt; 0
        ensures
            - returns an N by N identity matrix with elements of type T.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='linspace'></a>linspace</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'><u>double</u></font> start,
        <font color='#0000FF'><u>double</u></font> end,
        <font color='#0000FF'><u>long</u></font> num
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - num &gt;= 0
        ensures
            - returns a matrix M such that:
                - M::type == double 
                - is_row_vector(M) == true
                - M.size() == num
                - M == a row vector with num linearly spaced values beginning with start
                  and stopping with end.  
                - M(num-1) == end 
                - if (num &gt; 1) then
                    - M(0) == start
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='logspace'></a>logspace</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'><u>double</u></font> start,
        <font color='#0000FF'><u>double</u></font> end,
        <font color='#0000FF'><u>long</u></font> num
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - num &gt;= 0
        ensures
            - returns a matrix M such that:
                - M::type == double 
                - is_row_vector(M) == true
                - M.size() == num
                - M == a row vector with num logarithmically spaced values beginning with 
                  10^start and stopping with 10^end.  
                  (i.e. M == pow(10, linspace(start, end, num)))
                - M(num-1) == 10^end
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> R,
        <font color='#0000FF'><u>long</u></font> C
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='rotate'></a>rotate</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                  R( (r+R)%m.nr() , (c+C)%m.nc() ) == m(r,c)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='fliplr'></a>fliplr</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - flips the matrix m from left to right and returns the result.  
              I.e. reverses the order of the columns.
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - for all valid r and c:
                  M(r,c) == m(r, m.nc()-c-1)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='flipud'></a>flipud</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - flips the matrix m from up to down and returns the result.  
              I.e. reverses the order of the rows.
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - for all valid r and c:
                  M(r,c) == m(m.nr()-r-1, c)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> vector_type
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='vector_to_matrix'></a>vector_to_matrix</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> vector_type<font color='#5555FF'>&amp;</font> vector
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - vector_type is an implementation of array/array_kernel_abstract.h or
              std::vector or dlib::std_vector_c or dlib::matrix
        ensures
            - if (vector_type is a dlib::matrix) then
                - returns a reference to vector
            - else
                - returns a matrix R such that:
                    - is_col_vector(R) == true 
                    - R.size() == vector.size()
                    - for all valid r:
                      R(r) == vector[r]
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> array_type
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='array_to_matrix'></a>array_to_matrix</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> array_type<font color='#5555FF'>&amp;</font> array
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - array_type is an implementation of array2d/array2d_kernel_abstract.h
              or dlib::matrix
        ensures
            - if (array_type is a dlib::matrix) then
                - returns a reference to array 
            - else
                - returns a matrix R such that:
                    - R.nr() == array.nr() 
                    - R.nc() == array.nc()
                    - for all valid r and c:
                      R(r, c) == array[r][c]
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='pointer_to_matrix'></a>pointer_to_matrix</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>*</font> ptr,
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - nr &gt; 0
            - nc &gt; 0
            - ptr == a pointer to at least nr*nc T objects
        ensures
            - returns a matrix M such that:
                - M.nr() == nr
                - m.nc() == nc 
                - for all valid r and c:
                  M(r,c) == ptr[r*nc + c]
                  (i.e. the pointer is interpreted as a matrix laid out in memory
                  in row major order)
            - Note that the returned matrix doesn't take "ownership" of
              the pointer and thus will not delete or free it.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='pointer_to_column_vector'></a>pointer_to_column_vector</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>*</font> ptr,
        <font color='#0000FF'><u>long</u></font> nr
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - nr &gt; 0
            - ptr == a pointer to at least nr T objects
        ensures
            - returns a matrix M such that:
                - M.nr() == nr
                - m.nc() == 1
                - for all valid i:
                  M(i) == ptr[i]
            - Note that the returned matrix doesn't take "ownership" of
              the pointer and thus will not delete or free it.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='reshape'></a>reshape</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'><u>long</u></font> rows,
        <font color='#0000FF'><u>long</u></font> cols
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.size() == rows*cols
            - rows &gt; 0
            - cols &gt; 0
        ensures
            - returns a matrix M such that: 
                - M.nr() == rows
                - M.nc() == cols
                - M.size() == m.size()
                - for all valid r and c:
                    - let IDX = r*cols + c
                    - M(r,c) == m(IDX/m.nc(), IDX%m.nc())

            - i.e. The matrix m is reshaped into a new matrix of rows by cols
              dimension.  Additionally, the elements of m are laid into M in row major 
              order.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='reshape_to_column_vector'></a>reshape_to_column_vector</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix M such that: 
                - is_col_vector(M) == true
                - M.size() == m.size()
                - for all valid r and c:
                    - m(r,c) == M(r*m.nc() + c)

            - i.e. The matrix m is reshaped into a column vector.  Note that
              the elements are pulled out in row major order.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> R,
        <font color='#0000FF'><u>long</u></font> C
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='removerc'></a>removerc</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.nr() &gt; R &gt;= 0
            - m.nc() &gt; C &gt;= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() - 1
                - M.nc() == m.nc() - 1
                - M == m with its R row and C column removed
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='removerc'></a>removerc</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'><u>long</u></font> R,
        <font color='#0000FF'><u>long</u></font> C
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.nr() &gt; R &gt;= 0
            - m.nc() &gt; C &gt;= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() - 1
                - M.nc() == m.nc() - 1
                - M == m with its R row and C column removed
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> R
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='remove_row'></a>remove_row</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.nr() &gt; R &gt;= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() - 1
                - M.nc() == m.nc() 
                - M == m with its R row removed
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='remove_row'></a>remove_row</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'><u>long</u></font> R
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.nr() &gt; R &gt;= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() - 1
                - M.nc() == m.nc() 
                - M == m with its R row removed
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> C
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='remove_col'></a>remove_col</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.nc() &gt; C &gt;= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() 
                - M.nc() == m.nc() - 1 
                - M == m with its C column removed
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='remove_col'></a>remove_col</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'><u>long</u></font> C
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.nc() &gt; C &gt;= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() 
                - M.nc() == m.nc() - 1 
                - M == m with its C column removed
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
       <font color='#0000FF'>typename</font> target_type
       <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='matrix_cast'></a>matrix_cast</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix R where for all valid r and c:
              R(r,c) == static_cast&lt;target_type&gt;(m(r,c))
              also, R has the same dimensions as m.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'><u>long</u></font> NR,
        <font color='#0000FF'><u>long</u></font> NC,
        <font color='#0000FF'>typename</font> MM,
        <font color='#0000FF'>typename</font> U
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='set_all_elements'></a>set_all_elements</b> <font face='Lucida Console'>(</font>
        matrix<font color='#5555FF'>&lt;</font>T,NR,NC,MM<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> m,
        U value
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - for all valid r and c:
              m(r,c) == value
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::matrix_type <b><a name='tmp'></a>tmp</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a temporary matrix object that is a copy of m. 
              (This allows you to easily force a matrix_exp to fully evaluate)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#009900'>// if matrix_exp contains non-complex types (e.g. float, double)
</font>    <font color='#0000FF'><u>bool</u></font> <b><a name='equal'></a>equal</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> b,
        <font color='#0000FF'>const</font> matrix_exp::type epsilon <font color='#5555FF'>=</font> <font color='#979000'>100</font><font color='#5555FF'>*</font>std::numeric_limits<font color='#5555FF'>&lt;</font>matrix_exp::type<font color='#5555FF'>&gt;</font>::<font color='#BB00BB'>epsilon</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - if (a and b don't have the same dimensions) then
                - returns false
            - else if (there exists an r and c such that abs(a(r,c)-b(r,c)) &gt; epsilon) then
                - returns false
            - else
                - returns true
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#009900'>// if matrix_exp contains std::complex types 
</font>    <font color='#0000FF'><u>bool</u></font> <b><a name='equal'></a>equal</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> b,
        <font color='#0000FF'>const</font> matrix_exp::type::value_type epsilon <font color='#5555FF'>=</font> <font color='#979000'>100</font><font color='#5555FF'>*</font>std::numeric_limits<font color='#5555FF'>&lt;</font>matrix_exp::type::value_type<font color='#5555FF'>&gt;</font>::<font color='#BB00BB'>epsilon</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - if (a and b don't have the same dimensions) then
                - returns false
            - else if (there exists an r and c such that abs(real(a(r,c)-b(r,c))) &gt; epsilon 
              or abs(imag(a(r,c)-b(r,c))) &gt; epsilon) then
                - returns false
            - else
                - returns true
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='pointwise_multiply'></a>pointwise_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> b 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a.nr() == b.nr()
            - a.nc() == b.nc()
            - a and b both contain the same type of element (one or both
              can also be of type std::complex so long as the underlying type
              in them is the same)
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in a and b.
                - R has the same dimensions as a and b. 
                - for all valid r and c:
                  R(r,c) == a(r,c) * b(r,c)
    !*/</font>

    <font color='#0000FF'>const</font> matrix_exp <b><a name='pointwise_multiply'></a>pointwise_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> b,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> c 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        performs pointwise_multiply(a,pointwise_multiply(b,c));
    !*/</font>

    <font color='#0000FF'>const</font> matrix_exp <b><a name='pointwise_multiply'></a>pointwise_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> b,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> c,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> d 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        performs pointwise_multiply(pointwise_multiply(a,b),pointwise_multiply(c,d));
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='join_rows'></a>join_rows</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> b 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a.nr() == b.nr()
            - a and b both contain the same type of element
        ensures
            - This function joins two matrices together by concatenating their rows.
            - returns a matrix R such that:
                - R::type == the same type that was in a and b.
                - R.nr() == a.nr() == b.nr()
                - R.nc() == a.nc() + b.nc()
                - for all valid r and c:
                    - if (c &lt; a.nc()) then
                        - R(r,c) == a(r,c) 
                    - else
                        - R(r,c) == b(r, c-a.nc()) 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='join_cols'></a>join_cols</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> b 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a.nc() == b.nc()
            - a and b both contain the same type of element
        ensures
            - This function joins two matrices together by concatenating their columns.
            - returns a matrix R such that:
                - R::type == the same type that was in a and b.
                - R.nr() == a.nr() + b.nr()
                - R.nc() == a.nc() == b.nc()
                - for all valid r and c:
                    - if (r &lt; a.nr()) then
                        - R(r,c) == a(r,c) 
                    - else
                        - R(r,c) == b(r-a.nr(), c) 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='tensor_product'></a>tensor_product</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> b 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a and b both contain the same type of element
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in a and b.
                - R.nr() == a.nr() * b.nr()  
                - R.nc() == a.nc() * b.nc()  
                - for all valid r and c:
                  R(r,c) == a(r/b.nr(), c/b.nc()) * b(r%b.nr(), c%b.nc())
                - I.e. R is the tensor product of matrix a with matrix b
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='cartesian_product'></a>cartesian_product</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> A,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> B 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - A and B both contain the same type of element
        ensures
            - Think of A and B as sets of column vectors.  Then this function 
              returns a matrix that contains a set of column vectors that is
              the Cartesian product of the sets A and B.  That is, the resulting
              matrix contains every possible combination of vectors from both A and
              B.
            - returns a matrix R such that:
                - R::type == the same type that was in A and B.
                - R.nr() == A.nr() + B.nr()  
                - R.nc() == A.nc() * B.nc()  
                - Each column of R is the concatenation of a column vector
                  from A with a column vector from B.  
                - for all valid r and c:
                    - if (r &lt; A.nr()) then
                        - R(r,c) == A(r, c/B.nc())
                    - else
                        - R(r,c) == B(r-A.nr(), c%B.nc())
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='scale_columns'></a>scale_columns</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> v
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(v) == true
            - v.size() == m.nc()
            - m and v both contain the same type of element
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m and v.
                - R has the same dimensions as m. 
                - for all valid r and c:
                  R(r,c) == m(r,c) * v(c)
                - i.e. R is the result of multiplying each of m's columns by
                  the corresponding scalar in v.

            - Note that this function is identical to the expression m*diagm(v).  
              That is, the * operator is overloaded for this case and will invoke
              scale_columns() automatically as appropriate.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='scale_rows'></a>scale_rows</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> v
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(v) == true
            - v.size() == m.nr()
            - m and v both contain the same type of element
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m and v.
                - R has the same dimensions as m. 
                - for all valid r and c:
                  R(r,c) == m(r,c) * v(r)
                - i.e. R is the result of multiplying each of m's rows by
                  the corresponding scalar in v.

            - Note that this function is identical to the expression diagm(v)*m.  
              That is, the * operator is overloaded for this case and will invoke
              scale_rows() automatically as appropriate.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='sort_columns'></a>sort_columns</b> <font face='Lucida Console'>(</font>
        matrix<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> m,
        matrix<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> v
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_col_vector(v) == true
            - v.size() == m.nc()
            - m and v both contain the same type of element
        ensures
            - the dimensions for m and v are not changed
            - sorts the columns of m according to the values in v.
              i.e. 
                - #v == the contents of v but in sorted order according to
                  operator&lt;.  So smaller elements come first.
                - Let #v(new(i)) == v(i) (i.e. new(i) is the index element i moved to)
                - colm(#m,new(i)) == colm(m,i) 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='rsort_columns'></a>rsort_columns</b> <font face='Lucida Console'>(</font>
        matrix<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> m,
        matrix<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> v
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_col_vector(v) == true
            - v.size() == m.nc()
            - m and v both contain the same type of element
        ensures
            - the dimensions for m and v are not changed
            - sorts the columns of m according to the values in v.
              i.e. 
                - #v == the contents of v but in sorted order according to
                  operator&gt;.  So larger elements come first.
                - Let #v(new(i)) == v(i) (i.e. new(i) is the index element i moved to)
                - colm(#m,new(i)) == colm(m,i) 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::type <b><a name='length_squared'></a>length_squared</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(m) == true
        ensures
            - returns sum(squared(m))
              (i.e. returns the square of the length of the vector m)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::type <b><a name='length'></a>length</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(m) == true
        ensures
            - returns sqrt(sum(squared(m)))
              (i.e. returns the length of the vector m)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'><u>bool</u></font> <b><a name='is_row_vector'></a>is_row_vector</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - if (m.nr() == 1) then
                - return true
            - else
                - returns false
    !*/</font>

    <font color='#0000FF'><u>bool</u></font> <b><a name='is_col_vector'></a>is_col_vector</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - if (m.nc() == 1) then
                - return true
            - else
                - returns false
    !*/</font>

    <font color='#0000FF'><u>bool</u></font> <b><a name='is_vector'></a>is_vector</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - if (is_row_vector(m) || is_col_vector(m)) then
                - return true
            - else
                - returns false
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>//                      Thresholding relational operators 
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) &lt; s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s &lt; m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font><font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) &lt;= s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font><font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s &lt;= m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>&gt;</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) &gt; s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>&gt;</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s &gt; m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) &gt;= s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s &gt;= m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) == s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s == m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>!</font><font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) != s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='operator'></a>operator</b><font color='#5555FF'>!</font><font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> S<font color='#5555FF'>&amp;</font> s,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_built_in_scalar_type&lt;S&gt;::value == true 
            - is_built_in_scalar_type&lt;matrix_exp::type&gt;::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s != m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>//                              Statistics
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::type <b><a name='min'></a>min</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.size() &gt; 0
        ensures
            - returns the value of the smallest element of m
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::type <b><a name='max'></a>max</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.size() &gt; 0
        ensures
            - returns the value of the biggest element of m
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='find_min_and_max'></a>find_min_and_max</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        matrix_exp::type<font color='#5555FF'>&amp;</font> min_val,
        matrix_exp::type<font color='#5555FF'>&amp;</font> max_val
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.size() &gt; 0
        ensures
            - #min_val == min(m)
            - #max_val == max(m)
            - This function computes both the min and max in just one pass
              over the elements of the matrix m.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'><u>long</u></font> <b><a name='index_of_max'></a>index_of_max</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(m) == true
            - m.size() &gt; 0 
        ensures
            - returns the index of the largest element in m.  
              (i.e. m(index_of_max(m)) == max(m))
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'><u>long</u></font> <b><a name='index_of_min'></a>index_of_min</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(m) == true
            - m.size() &gt; 0 
        ensures
            - returns the index of the smallest element in m.  
              (i.e. m(index_of_min(m)) == min(m))
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::type <b><a name='sum'></a>sum</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns the sum of all elements in m
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='sum_rows'></a>sum_rows</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.size() &gt; 0
        ensures
            - returns a row matrix that contains the sum of all the rows in m. 
            - returns a matrix M such that
                - M::type == the same type that was in m
                - M.nr() == 1
                - M.nc() == m.nc()
                - for all valid i:
                    - M(i) == sum(colm(m,i)) 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='sum_cols'></a>sum_cols</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m.size() &gt; 0
        ensures
            - returns a column matrix that contains the sum of all the columns in m. 
            - returns a matrix M such that
                - M::type == the same type that was in m
                - M.nr() == m.nr() 
                - M.nc() == 1
                - for all valid i:
                    - M(i) == sum(rowm(m,i)) 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::type <b><a name='prod'></a>prod</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns the results of multiplying all elements of m together. 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::type <b><a name='mean'></a>mean</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns the mean of all elements in m. 
              (i.e. returns sum(m)/(m.nr()*m.nc()))
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp::type <b><a name='variance'></a>variance</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns the unbiased sample variance of all elements in m 
              (i.e. 1.0/(m.nr()*m.nc() - 1)*(sum of all pow(m(i,j) - mean(m),2)))
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix <b><a name='covariance'></a>covariance</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - matrix_exp::type == a dlib::matrix object
            - is_col_vector(m) == true
            - m.size() &gt; 1
            - for all valid i, j:
                - is_col_vector(m(i)) == true 
                - m(i).size() &gt; 0
                - m(i).size() == m(j).size() 
                - i.e. m contains only column vectors and all the column vectors
                  have the same non-zero length
        ensures
            - returns the unbiased sample covariance matrix for the set of samples
              in m.  
              (i.e. 1.0/(m.nr()-1)*(sum of all (m(i) - mean(m))*trans(m(i) - mean(m))))
            - the returned matrix will contain elements of type matrix_exp::type::type.
            - the returned matrix will have m(0).nr() rows and columns.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> rand_gen<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'><u>double</u></font><font color='#5555FF'>&gt;</font> <b><a name='randm'></a>randm</b><font face='Lucida Console'>(</font> 
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc,
        rand_gen<font color='#5555FF'>&amp;</font> rnd
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - nr &gt;= 0
            - nc &gt;= 0
            - rand_gen == an object that implements the rand/rand_float_abstract.h interface
        ensures
            - generates a random matrix using the given rnd random number generator
            - returns a matrix M such that
                - M::type == double
                - M.nr() == nr
                - M.nc() == nc
                - for all valid i, j:
                    - M(i,j) == a random number such that 0 &lt;= M(i,j) &lt; 1
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>inline</font> <font color='#0000FF'>const</font> matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'><u>double</u></font><font color='#5555FF'>&gt;</font> <b><a name='randm'></a>randm</b><font face='Lucida Console'>(</font> 
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - nr &gt;= 0
            - nc &gt;= 0
        ensures
            - generates a random matrix using std::rand() 
            - returns a matrix M such that
                - M::type == double
                - M.nr() == nr
                - M.nc() == nc
                - for all valid i, j:
                    - M(i,j) == a random number such that 0 &lt;= M(i,j) &lt; 1
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>//                                 Pixel and Image Utilities
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'>typename</font> P
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='pixel_to_vector'></a>pixel_to_vector</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> P<font color='#5555FF'>&amp;</font> pixel
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - pixel_traits&lt;P&gt; must be defined
        ensures
            - returns a matrix M such that:
                - M::type == T
                - M::NC == 1 
                - M::NR == pixel_traits&lt;P&gt;::num
                - if (pixel_traits&lt;P&gt;::grayscale) then
                    - M(0) == pixel 
                - if (pixel_traits&lt;P&gt;::rgb) then
                    - M(0) == pixel.red 
                    - M(1) == pixel.green 
                    - M(2) == pixel.blue 
                - if (pixel_traits&lt;P&gt;::hsi) then
                    - M(0) == pixel.h 
                    - M(1) == pixel.s 
                    - M(2) == pixel.i 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> P
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='vector_to_pixel'></a>vector_to_pixel</b> <font face='Lucida Console'>(</font>
        P<font color='#5555FF'>&amp;</font> pixel,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> vector 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - vector::NR == pixel_traits&lt;P&gt;::num
            - vector::NC == 1 
              (i.e. you have to use a statically dimensioned vector)
        ensures
            - if (pixel_traits&lt;P&gt;::grayscale) then
                - pixel == M(0) 
            - if (pixel_traits&lt;P&gt;::rgb) then
                - pixel.red   == M(0)  
                - pixel.green == M(1) 
                - pixel.blue  == M(2)  
            - if (pixel_traits&lt;P&gt;::hsi) then
                - pixel.h == M(0)
                - pixel.s == M(1)
                - pixel.i == M(2)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> lower,
        <font color='#0000FF'><u>long</u></font> upper 
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='clamp'></a>clamp</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                    - if (m(r,c) &gt; upper) then
                        - R(r,c) == upper
                    - else if (m(r,c) &lt; lower) then
                        - R(r,c) == lower
                    - else
                        - R(r,c) == m(r,c)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> matrix_exp <b><a name='clamp'></a>clamp</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> matrix_exp::type<font color='#5555FF'>&amp;</font> lower,
        <font color='#0000FF'>const</font> matrix_exp::type<font color='#5555FF'>&amp;</font> upper
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                    - if (m(r,c) &gt; upper) then
                        - R(r,c) == upper
                    - else if (m(r,c) &lt; lower) then
                        - R(r,c) == lower
                    - else
                        - R(r,c) == m(r,c)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
<b>}</b>

<font color='#0000FF'>#endif</font> <font color='#009900'>// DLIB_MATRIx_UTILITIES_ABSTRACT_
</font>

</pre></body></html>