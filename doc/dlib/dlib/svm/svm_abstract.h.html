<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - svm_abstract.h</title></head><body bgcolor='white'><pre>
<font color='#009900'>// Copyright (C) 2007  Davis E. King (davis@dlib.net)
</font><font color='#009900'>// License: Boost Software License   See LICENSE.txt for the full license.
</font><font color='#0000FF'>#undef</font> DLIB_SVm_ABSTRACT_
<font color='#0000FF'>#ifdef</font> DLIB_SVm_ABSTRACT_

<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>cmath<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>limits<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>sstream<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../matrix/matrix_abstract.h.html'>../matrix/matrix_abstract.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../algs.h.html'>../algs.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../serialize.h.html'>../serialize.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='function_abstract.h.html'>function_abstract.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='kernel_abstract.h.html'>kernel_abstract.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='svm_nu_trainer_abstract.h.html'>svm_nu_trainer_abstract.h</a>"

<font color='#0000FF'>namespace</font> dlib
<b>{</b>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'>typename</font> U
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>bool</u></font> <b><a name='is_learning_problem'></a>is_learning_problem</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> x,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> x_labels
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - T == a matrix or something convertible to a matrix via vector_to_matrix()
            - U == a matrix or something convertible to a matrix via vector_to_matrix()
        ensures
            - returns true if all of the following are true and false otherwise:
                - is_col_vector(x) == true
                - is_col_vector(x_labels) == true
                - x.size() == x_labels.size() 
                - x.size() &gt; 0
    !*/</font>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'>typename</font> U
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>bool</u></font> <b><a name='is_binary_classification_problem'></a>is_binary_classification_problem</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> x,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> x_labels
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - T == a matrix or something convertible to a matrix via vector_to_matrix()
            - U == a matrix or something convertible to a matrix via vector_to_matrix()
        ensures
            - returns true if all of the following are true and false otherwise:
                - is_learning_problem(x, x_labels) == true
                - x.size() &gt; 1
                - there exists at least one sample from both the +1 and -1 classes.
                  (i.e. all samples can't have the same label)
                - for all valid i:
                    - x_labels(i) == -1 or +1
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> trainer_type,
        <font color='#0000FF'>typename</font> sample_type,
        <font color='#0000FF'>typename</font> scalar_type,
        <font color='#0000FF'>typename</font> alloc_type1,
        <font color='#0000FF'>typename</font> alloc_type2
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> probabilistic_function<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> trainer_type::trained_function_type<font color='#5555FF'>&gt;</font> 
    <b><a name='train_probabilistic_decision_function'></a>train_probabilistic_decision_function</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> trainer_type<font color='#5555FF'>&amp;</font> trainer,
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>sample_type,alloc_type1<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> x,
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>scalar_type,alloc_type2<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> y,
        <font color='#0000FF'>const</font> <font color='#0000FF'><u>long</u></font> folds
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - 1 &lt; folds &lt;= x.size()
            - is_binary_classification_problem(x,y) == true
            - trainer_type == some kind of batch trainer object (e.g. svm_nu_trainer)
        ensures
            - trains a classifier given the training samples in x and labels in y.  
            - returns a probabilistic_decision_function that represents the trained classifier.
            - The parameters of the probability model are estimated by performing k-fold 
              cross validation. 
            - The number of folds used is given by the folds argument.
        throws
            - any exceptions thrown by trainer.train()
            - std::bad_alloc
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> trainer_type
        <font color='#5555FF'>&gt;</font>
    trainer_adapter_probabilistic<font color='#5555FF'>&lt;</font>trainer_type<font color='#5555FF'>&gt;</font> <b><a name='probabilistic'></a>probabilistic</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> trainer_type<font color='#5555FF'>&amp;</font> trainer,
        <font color='#0000FF'>const</font> <font color='#0000FF'><u>long</u></font> folds
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - 1 &lt; folds &lt;= x.size()
            - trainer_type == some kind of batch trainer object (e.g. svm_nu_trainer)
        ensures
            - returns a trainer adapter TA such that calling TA.train(samples, labels)
              returns the same object as calling train_probabilistic_decision_function(trainer,samples,labels,folds).
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>//                                  Miscellaneous functions
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> trainer_type,
        <font color='#0000FF'>typename</font> in_sample_vector_type,
        <font color='#0000FF'>typename</font> in_scalar_vector_type
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> trainer_type::scalar_type, <font color='#979000'>1</font>, <font color='#979000'>2</font>, <font color='#0000FF'>typename</font> trainer_type::mem_manager_type<font color='#5555FF'>&gt;</font> 
    <b><a name='cross_validate_trainer'></a>cross_validate_trainer</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> trainer_type<font color='#5555FF'>&amp;</font> trainer,
        <font color='#0000FF'>const</font> in_sample_vector_type<font color='#5555FF'>&amp;</font> x,
        <font color='#0000FF'>const</font> in_scalar_vector_type<font color='#5555FF'>&amp;</font> y,
        <font color='#0000FF'>const</font> <font color='#0000FF'><u>long</u></font> folds
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_binary_classification_problem(x,y) == true
            - 1 &lt; folds &lt;= x.nr()
            - trainer_type == some kind of binary classification trainer object (e.g. svm_nu_trainer)
        ensures
            - performs k-fold cross validation by using the given trainer to solve the
              given binary classification problem for the given number of folds.
              Each fold is tested using the output of the trainer and the average 
              classification accuracy from all folds is returned.  
            - The average accuracy is computed by running test_binary_decision_function()
              on each fold and its output is averaged and returned.
            - The number of folds used is given by the folds argument.
        throws
            - any exceptions thrown by trainer.train()
            - std::bad_alloc
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> dec_funct_type,
        <font color='#0000FF'>typename</font> in_sample_vector_type,
        <font color='#0000FF'>typename</font> in_scalar_vector_type
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> dec_funct_type::scalar_type, <font color='#979000'>1</font>, <font color='#979000'>2</font>, <font color='#0000FF'>typename</font> dec_funct_type::mem_manager_type<font color='#5555FF'>&gt;</font> 
    <b><a name='test_binary_decision_function'></a>test_binary_decision_function</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> dec_funct_type<font color='#5555FF'>&amp;</font> dec_funct,
        <font color='#0000FF'>const</font> in_sample_vector_type<font color='#5555FF'>&amp;</font> x_test,
        <font color='#0000FF'>const</font> in_scalar_vector_type<font color='#5555FF'>&amp;</font> y_test
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_binary_classification_problem(x_test,y_test) == true
            - dec_funct_type == some kind of decision function object (e.g. decision_function)
        ensures
            - Tests the given decision function by calling it on the x_test and y_test samples.
              The output of dec_funct is interpreted as a prediction for the +1 class
              if its output is &gt;= 0 and as a prediction for the -1 class otherwise.
            - The test accuracy is returned in a row vector, let us call it R.  Both 
              quantities in R are numbers between 0 and 1 which represent the fraction 
              of examples correctly classified.  R(0) is the fraction of +1 examples 
              correctly classified and R(1) is the fraction of -1 examples correctly 
              classified.
        throws
            - std::bad_alloc
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'>typename</font> U
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='randomize_samples'></a>randomize_samples</b> <font face='Lucida Console'>(</font>
        T<font color='#5555FF'>&amp;</font> samples,
        U<font color='#5555FF'>&amp;</font> labels 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - T == a matrix object or an object compatible with std::vector that contains 
              a swappable type.
            - U == a matrix object or an object compatible with std::vector that contains 
              a swappable type.
            - if samples or labels are matrix objects then is_vector(samples) == true and
              is_vector(labels) == true
            - samples.size() == labels.size()
        ensures
            - randomizes the order of the samples and labels but preserves
              the pairing between each sample and its label
            - A default initialized random number generator is used to perform the randomizing.
              Note that this means that each call this this function does the same thing.  
              That is, the random number generator always uses the same seed.
            - for all valid i:
                - let r == the random index samples(i) was moved to.  then:
                    - #labels(r) == labels(i)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'>typename</font> U,
        <font color='#0000FF'>typename</font> rand_type
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='randomize_samples'></a>randomize_samples</b> <font face='Lucida Console'>(</font>
        T<font color='#5555FF'>&amp;</font> samples,
        U<font color='#5555FF'>&amp;</font> labels,
        rand_type<font color='#5555FF'>&amp;</font> rnd
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - T == a matrix object or an object compatible with std::vector that contains 
              a swappable type.
            - U == a matrix object or an object compatible with std::vector that contains 
              a swappable type.
            - if samples or labels are matrix objects then is_vector(samples) == true and
              is_vector(labels) == true
            - samples.size() == labels.size()
            - rand_type == a type that implements the dlib/rand/rand_kernel_abstract.h interface
        ensures
            - randomizes the order of the samples and labels but preserves
              the pairing between each sample and its label
            - the given rnd random number generator object is used to do the randomizing
            - for all valid i:
                - let r == the random index samples(i) was moved to.  then:
                    - #labels(r) == labels(i)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='randomize_samples'></a>randomize_samples</b> <font face='Lucida Console'>(</font>
        T<font color='#5555FF'>&amp;</font> samples
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - T == a matrix object or an object compatible with std::vector that contains 
              a swappable type.
            - if samples is a matrix then is_vector(samples) == true 
        ensures
            - randomizes the order of the elements inside samples 
            - A default initialized random number generator is used to perform the randomizing.
              Note that this means that each call this this function does the same thing.  
              That is, the random number generator always uses the same seed.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'>typename</font> rand_type
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='randomize_samples'></a>randomize_samples</b> <font face='Lucida Console'>(</font>
        T<font color='#5555FF'>&amp;</font> samples,
        rand_type<font color='#5555FF'>&amp;</font> rnd
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - T == a matrix object or an object compatible with std::vector that contains 
              a swappable type.
            - if samples is a matrix then is_vector(samples) == true 
        ensures
            - randomizes the order of the elements inside samples 
            - the given rnd random number generator object is used to do the randomizing
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
<b>}</b>

<font color='#0000FF'>#endif</font> <font color='#009900'>// DLIB_SVm_ABSTRACT_
</font>


</pre></body></html>